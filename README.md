# Racket iTunes Playlist Maker
### I developed an application in Racket that takes an iTunes library.xml file as input, and outputs multiple .txt files containing generated playlists. I used the built in racket/gui library for the user interface. The 2htdp library was used both for file writing and for converting the .xml file to a list of song tracks. My application outputs four different playlists.

---
# A Brief Overview of the Playlists
- Top Ten Playlist:  The top ten playlist is generated by taking the top ten most played songs in the .xml file
- Single Played Playlist:  The single played playlist is generated by taking all the songs that have only been played once in the .xml file.
- Random Playlist:  The random playist is generated by randomly picking each song in the .xml file, with a 25% chance for a song to be picked.
- Random Weighted Playlist:  The random weighted playlist is generated by randomly picking each song in the .xml with a weight being placed on how many plays the song has. The chance for a song to be picked starts at 50% chance for the most played song in the .xml file, and increases as the number of plays decreases.

---
# An in depth look at how each playlist is generated

## Top Ten Playlist
#### I decided that the most efficient way to get the top ten most played songs out of the .xml file would be to use a max heap. I created a max heap class and implemented public methods for inserting elements, extracting elements, reading the top element, and checking if the heap was empty. I weighted each element in the heap by the number of plays that the song had. Once all the songs had been inserted into the heap, it was really easy to get the top ten most played songs. All that had to be done was extracting from the heap ten times.

## Single Played Playlist
#### I decided that the using a heap data structure would not improve efficiency for finding each song that was only played once. My reasoning behind this was that in order to use a heap all the elements of the list must be traversed in order to insert them into the heap. Then the elements would have to be extracted from the heap. By keeping all of the elements in a list to find each song with a single play, all the elements in the list would only have to be traversed once. My method for finding each element in the list with only one play was to traverse the list tail recursively and append each element that had only one play to the accumulator of the method.

## Random Playlist
#### I decided to use a list again for similar reasons that I used a list in the single played playlist. My method for randomly picking elements out of the list was to tail recursively traverse the list, with a 50% chance to append each element to the accumulator of the method. To get a 50% chance I randomly generated an integer between 0 and 1, with 0 being false and 1 being true. 

## Random Weighted Playlist
#### This method was very similar to the method I used for the random playlist. The main difference was how I chose whether or not to pick an element out of the list to append to the accumulator. To weight the songs I randomly generated a number between 0 and 2 times the number of plays of the most played song. If the number of plays of the song was less than the randomly generated integer, then the song was appended to the accumulator. This resulted in a 50% chance for the most played song to be in the playlist, and an increasing chance for each song as the amount of plays decreased.
